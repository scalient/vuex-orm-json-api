import Utils from '../Utils';
import FieldTransformer from './FieldTransformer';

export default class extends FieldTransformer {
  constructor(name, relation, config) {
    super(name);

    this.relation = relation;
    this.resourceToEntityCase = config.resourceToEntityCase;
    this.isPolymorphic = !!(relation.id && relation.type);
  }

  transform(_data, _output, _id = null, _insertionStore = null) {
    throw Utils.error('Method not implemented');
  }

  static checkType(type, expectedModel) {
    /*
     * We can guarantee that the model is the bound version generated by a Vuex ORM database (see
     * `https://github.com/vuex-orm/vuex-orm/blob/c771f9b/src/database/Database.ts#L186-L216`).
     */
    const database = expectedModel.database();

    const model = Utils.modelFor(database, type);
    const baseType = model.baseEntity;
    const expectedType = expectedModel.entity;
    const expectedBaseType = expectedModel.baseEntity;

    if (type === expectedBaseType) {
      // The object's type is a superclass of the expected type: Do nothing and let the operation proceed.

      // TODO: Technically speaking, we should check the mapped STI type.
    } else if (baseType === expectedType) {
      // The object's type is a subclass of the expected type: Do nothing and let the operation proceed.
    } else if (type !== expectedType) {
      // If the object's type isn't the expected type and all of the above falls through, just throw an error.
      throw Utils.error(`Expected type \`${expectedType}\` but got \`${type}\` in relation`);
    }
  }

  static checkMany(data) {
    if (!(data instanceof Array)) {
      throw Utils.error('Expected relation data to be an array');
    }
  }

  static checkSingleton(data) {
    if (data instanceof Array) {
      throw Utils.error('Expected relation data to be an object');
    }
  }
}
